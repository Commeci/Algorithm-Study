# 실패율

**[프로그래머스-2019 KAKAO BLIND RECRUITMENT-실패율](https://school.programmers.co.kr/learn/courses/30/lessons/42889)**

## 문제 설명

![48ddf1cc-c4ea-499d-b431-9727ee799191](https://github.com/user-attachments/assets/bfe1b1b8-0cac-449e-90d9-32f3ebd4624a)

슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.

이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.

- 실패율은 다음과 같이 정의한다.
  - 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수

전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.

## 제약 조건

- 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.
- stages의 길이는 1 이상 200,000 이하이다.
- stages에는 1 이상 N + 1 이하의 자연수가 담겨있다.
  - 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.
  - 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.
- 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.
- 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.

## 예제 입/출력

### 예제1

**입력**

| N   | stages                   |
| --- | ------------------------ |
| 5   | [2, 1, 2, 6, 2, 4, 3, 3] |

**출력**

| result      |
| ----------- |
| [3,4,2,1,5] |

입출력 예 #1
1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.

- 1 번 스테이지 실패율 : 1/8

2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다.

- 2 번 스테이지 실패율 : 3/7

마찬가지로 나머지 스테이지의 실패율은 다음과 같다.

- 3 번 스테이지 실패율 : 2/4
- 4번 스테이지 실패율 : 1/2
- 5번 스테이지 실패율 : 0/1

각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.

- [3,4,2,1,5]

### 예제2

**입력**

| N   | stages      |
| --- | ----------- |
| 4   | [4,4,4,4,4] |

**출력**

| result    |
| --------- |
| [4,1,2,3] |

모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.

- [4,1,2,3]

## 접근 방식

### 시간 복잡도

- **M + NlogN**
- challengers 배열 초기화하는데 O(N)이 걸리고, 스테이지 당 유저수 계산하는데 O(M)이 걸립니다. 실패율 계산하는데 O(N)이 걸리고, sort로 정렬하는데 O(NlogN)이 걸립니다. 그래서 총 O(N+M) + O(N) + O(Nlong)이 걸리는데 가장 높은 시간복잡도가 최종 시간복잡도를 결정하므로 O(M + NlogN)입니다. M이 매우 크다면 O(M)도 고려할 수 있기 때문입니다.

### 자료구조

- **Map 객체**
- Map은 key-value 쌍으로 이루어진 자바스크립트 객체로, 인덱스를 key로 실패율을 value로 담기위해 사용하였습니다.

### 알고리즘

- **sort()**
- 내림차순으로 정렬하기 위해 사용하였습니다.

## 소스 코드

```js
function solution(N, stages) {
  //실패율 = 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수
  //지금 stages는 예시로 첫번째 사용자가 2번 스테이지에 있다라는 걸 뜻하니깐
  //각 스테이지의 몇명있는지 우선 정리를 한다. 플레이어의 수가 중요하니깐..

  //스테이지의 수로 우선 배열을 만들어준다.
  //stage가 1번부터이기때문에 0번은 버리고, N+1까지 가기때문에 N+2로 만들어준다.
  const challengers = new Array(N + 2).fill(0);
  for (const stage of stages) {
    //2번의 1명, 1번의 1명.. 계속 더해준다
    //스테이지당 몇명이 있는지 알수있다
    challengers[stage] += 1;
  }

  //실패율을 담을 Map
  const fails = new Map();
  let total = stages.length; //총 사용자 수

  for (let i = 1; i <= N; i++) {
    if (challengers[i] === 0) {
      fails.set(i, 0); //0이면 그냥 실패율 0
      continue; //다음 반복문으로 넘어간다
    }

    //클리어하지못했기때문에 이 스테이지에 있는것이다
    fails.set(i, challengers[i] / total); //인덱스를 key로 실패율을 value로
    //앞에 도달하지못한 유저를 빼줘야한다.
    total -= challengers[i];
  }

  return [...fails].sort((a, b) => b[1] - a[1]).map((v) => v[0]);
}
```
